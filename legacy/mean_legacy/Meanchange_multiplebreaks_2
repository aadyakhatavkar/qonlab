import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

from statsmodels.tsa.arima.model import ARIMA

# =========================================================
# 1) DGP: AR(1) with TWO deterministic mean breaks
# =========================================================
def simulate_multiple_mean_breaks(
    T=300,
    b1=100,
    b2=200,
    mu0=0.0,
    mu1=2.0,
    mu2=-2.0,
    phi=0.6,
    sigma=1.0,
    y0=0.0,
    rng=None
):
    if rng is None:
        rng = np.random.default_rng()

    y = np.zeros(T, dtype=float)
    y[0] = y0
    for t in range(1, T):
        if t <= b1:
            mu = mu0
        elif t <= b2:
            mu = mu1
        else:
            mu = mu2
        y[t] = mu + phi * y[t-1] + rng.normal(0.0, sigma)
    return y


# =========================================================
# 2) Forecasting methods (1-step ahead)
# =========================================================
def forecast_global_ar1(y_train):
    m = ARIMA(y_train, order=(1,0,0)).fit()
    return float(m.forecast(1)[0])

def forecast_rolling_ar1(y_train, window=60):
    y_sub = y_train[-window:] if len(y_train) > window else y_train
    m = ARIMA(y_sub, order=(1,0,0)).fit()
    return float(m.forecast(1)[0])

def forecast_ar1_multiple_break_dummies_oracle(y_train, b1, b2):
    """
    OLS version (stable):
      y_t = c + phi*y_{t-1} + a1*1(t>b1) + a2*1(t>b2) + e_t
    """
    y = np.asarray(y_train, dtype=float)
    if len(y) < 10:
        raise ValueError("Too little data to fit dummy model.")

    y_dep = y[1:]
    y_lag = y[:-1]
    t_idx = np.arange(1, len(y))  # times for y_dep

    d1 = (t_idx > b1).astype(float)
    d2 = (t_idx > b2).astype(float)

    X = np.column_stack([np.ones_like(y_lag), y_lag, d1, d2])
    beta = np.linalg.lstsq(X, y_dep, rcond=None)[0]  # c, phi, a1, a2
    c, phi, a1, a2 = beta

    t_next = len(y)  # next time index
    d1_next = 1.0 if t_next > b1 else 0.0
    d2_next = 1.0 if t_next > b2 else 0.0
    return float(c + phi*y[-1] + a1*d1_next + a2*d2_next)


# =========================================================
# 3) Monte Carlo evaluation (forecast after last break)
# =========================================================
def run_monte_carlo_multiple_breaks(
    n_sim=200,
    T=300,
    b1=100,
    b2=200,
    window=60,
    seed=123,
    mu0=0.0,
    mu1=2.0,
    mu2=-2.0,
    phi=0.6,
    sigma=1.0,
    gap_after_last_break=20
):
    rng = np.random.default_rng(seed)
    t0 = b2 + gap_after_last_break
    if t0 >= T:
        raise ValueError("gap_after_last_break too large for T.")

    errors = {
        "ARIMA Global (AR1)": [],
        "ARIMA Rolling (AR1)": [],
        "AR1 + 2 Break Dummies (oracle b1,b2)": [],
    }
    fails = {k: 0 for k in errors}

    for _ in range(n_sim):
        y = simulate_multiple_mean_breaks(
            T=T, b1=b1, b2=b2,
            mu0=mu0, mu1=mu1, mu2=mu2,
            phi=phi, sigma=sigma, rng=rng
        )
        y_train = y[:t0]
        y_true  = float(y[t0])

        # each method independent
        try:
            f = forecast_global_ar1(y_train)
            errors["ARIMA Global (AR1)"].append(y_true - f)
        except Exception:
            fails["ARIMA Global (AR1)"] += 1

        try:
            f = forecast_rolling_ar1(y_train, window=window)
            errors["ARIMA Rolling (AR1)"].append(y_true - f)
        except Exception:
            fails["ARIMA Rolling (AR1)"] += 1

        try:
            f = forecast_ar1_multiple_break_dummies_oracle(y_train, b1=b1, b2=b2)
            errors["AR1 + 2 Break Dummies (oracle b1,b2)"].append(y_true - f)
        except Exception:
            fails["AR1 + 2 Break Dummies (oracle b1,b2)"] += 1

    def metrics(e):
        e = np.asarray(e, dtype=float)
        return {
            "RMSE": float(np.sqrt(np.mean(e**2))),
            "MAE":  float(np.mean(np.abs(e))),
            "Bias": float(np.mean(e)),
            "N": int(len(e))
        }

    rows = []
    for method, e in errors.items():
        if len(e) == 0:
            rows.append({"Method": method, "RMSE": np.nan, "MAE": np.nan, "Bias": np.nan, "N": 0, "Fails": fails[method]})
        else:
            rows.append({"Method": method, **metrics(e), "Fails": fails[method]})

    results = pd.DataFrame(rows).sort_values("RMSE", na_position="last").reset_index(drop=True)
    return results


# =========================================================
# 4) RUN + PRINT RESULTS
# =========================================================
T=300; b1=100; b2=200
mu0=0.0; mu1=2.0; mu2=-2.0
phi=0.6; sigma=1.0
window=60
gap_after_last_break=20

results_multi = run_monte_carlo_multiple_breaks(
    n_sim=200,
    T=T,
    b1=b1,
    b2=b2,
    window=window,
    seed=123,
    mu0=mu0,
    mu1=mu1,
    mu2=mu2,
    phi=phi,
    sigma=sigma,
    gap_after_last_break=gap_after_last_break
)

print("\nMultiple-break results (lower RMSE = better):")
print(results_multi.to_string(index=False))

best = results_multi.dropna(subset=["RMSE"]).head(1)
if len(best) > 0:
    print(f"\nBest method (multiple breaks): {best.iloc[0]['Method']}")
else:
    print("\nNo method produced results (unexpected).")


# =========================================================
# 5) VISUALS
# =========================================================

# --- A) Example simulated series with two break lines
rng_demo = np.random.default_rng(999)
y_demo = simulate_multiple_mean_breaks(
    T=T, b1=b1, b2=b2, mu0=mu0, mu1=mu1, mu2=mu2, phi=phi, sigma=sigma, rng=rng_demo
)

plt.figure(figsize=(12,4))
plt.plot(y_demo, label="Simulated y_t")
plt.axvline(b1, linestyle="--", linewidth=2, label=f"Break b1={b1}")
plt.axvline(b2, linestyle="--", linewidth=2, label=f"Break b2={b2}")
plt.title("Example series: AR(1) with TWO mean breaks")
plt.xlabel("Time")
plt.ylabel("y")
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

# --- B) Bar charts: RMSE, MAE, Bias
plot_df = results_multi.sort_values("RMSE", na_position="last").reset_index(drop=True)

plt.figure(figsize=(12,4))
plt.bar(plot_df["Method"], plot_df["RMSE"])
plt.title("Multiple breaks: RMSE by method (lower is better)")
plt.ylabel("RMSE")
plt.grid(True, axis="y", alpha=0.3)
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

plt.figure(figsize=(12,4))
plt.bar(plot_df["Method"], plot_df["MAE"])
plt.title("Multiple breaks: MAE by method (lower is better)")
plt.ylabel("MAE")
plt.grid(True, axis="y", alpha=0.3)
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

plt.figure(figsize=(12,4))
plt.bar(plot_df["Method"], plot_df["Bias"])
plt.axhline(0, linestyle="--", linewidth=2)
plt.title("Multiple breaks: Bias by method (closer to 0 is better)")
plt.ylabel("Bias")
plt.grid(True, axis="y", alpha=0.3)
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

# --- C) One-path forecast comparison at t0 = b2 + gap
t0 = b2 + gap_after_last_break
y_train = y_demo[:t0]
y_true = float(y_demo[t0])

fg = forecast_global_ar1(y_train)
fr = forecast_rolling_ar1(y_train, window=window)
fd = forecast_ar1_multiple_break_dummies_oracle(y_train, b1=b1, b2=b2)

labels = ["Global", "Rolling", "2-dummy (oracle)", "True"]
vals   = [fg, fr, fd, y_true]

plt.figure(figsize=(10,4))
plt.bar(labels, vals)
plt.title(f"One-step forecast comparison on example path at t0 = b2 + {gap_after_last_break} = {t0}")
plt.ylabel("Forecast / True value")
plt.grid(True, axis="y", alpha=0.3)
plt.tight_layout()
plt.show()


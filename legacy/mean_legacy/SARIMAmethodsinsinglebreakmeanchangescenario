import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.holtwinters import SimpleExpSmoothing


# =========================================================
# 1) DGP: AR(1) + SEASONALITY + ONE mean break
# =========================================================
def simulate_single_break_with_seasonality(
    T=300,
    Tb=150,
    mu0=0.0,
    mu1=2.0,
    phi=0.6,
    sigma=1.0,
    s=12,            # seasonal period
    A=1.0,           # seasonal amplitude
    y0=0.0,
    rng=None
):
    """
    DGP:
      y_t = mu_t + seasonal_t + phi*y_{t-1} + eps_t
      mu_t = mu0 for t <= Tb, mu1 for t > Tb
      seasonal_t = A * sin(2Ï€ t / s)
    """
    if rng is None:
        rng = np.random.default_rng()

    y = np.zeros(T, dtype=float)
    y[0] = y0

    for t in range(1, T):
        mu = mu0 if t <= Tb else mu1
        seasonal = A * np.sin(2*np.pi*t/s)
        y[t] = mu + seasonal + phi*y[t-1] + rng.normal(0.0, sigma)

    return y


# =========================================================
# 2) SARIMA forecasting methods (1-step ahead)
# =========================================================
def forecast_sarima_global(y_train, order=(1,0,0), seasonal_order=(1,0,0,12)):
    """
    SARIMA(p,d,q)(P,D,Q)_s implemented as SARIMAX.
    """
    m = SARIMAX(
        y_train,
        order=order,
        seasonal_order=seasonal_order,
        trend="c",
        enforce_stationarity=False,
        enforce_invertibility=False
    ).fit(disp=False)
    return float(m.forecast(1)[0])

def forecast_sarima_rolling(y_train, window=60, order=(1,0,0), seasonal_order=(1,0,0,12)):
    sub = y_train[-window:] if len(y_train) > window else y_train
    m = SARIMAX(
        sub,
        order=order,
        seasonal_order=seasonal_order,
        trend="c",
        enforce_stationarity=False,
        enforce_invertibility=False
    ).fit(disp=False)
    return float(m.forecast(1)[0])

def forecast_sarima_break_dummy_oracle(y_train, Tb, order=(1,0,0), seasonal_order=(1,0,0,12)):
    """
    SARIMA with exogenous break dummy (oracle Tb).
    Model includes dummy in exog to shift the mean after Tb.
    """
    y = np.asarray(y_train, dtype=float)
    t_idx = np.arange(len(y))
    d = (t_idx > Tb).astype(float).reshape(-1, 1)

    m = SARIMAX(
        y,
        order=order,
        seasonal_order=seasonal_order,
        exog=d,
        trend="c",
        enforce_stationarity=False,
        enforce_invertibility=False
    ).fit(disp=False)

    # next-step dummy value
    d_next = np.array([[1.0 if len(y) > Tb else 0.0]])
    return float(m.forecast(1, exog=d_next)[0])

def estimate_break_grid_sse_mean_only(y_train, trim=0.15):
    """
    Simple break estimator:
    choose Tb_hat that minimizes SSE of two means (level shift only).
    (This is robust and fast for teaching purposes.)
    """
    y = np.asarray(y_train, dtype=float)
    Tn = len(y)
    lo = max(int(trim*Tn), 10)
    hi = min(int((1-trim)*Tn)-1, Tn-10)

    best_Tb, best_sse = None, np.inf
    for Tb in range(lo, hi):
        m1 = np.mean(y[:Tb+1])
        m2 = np.mean(y[Tb+1:])
        sse = np.sum((y[:Tb+1]-m1)**2) + np.sum((y[Tb+1:]-m2)**2)
        if sse < best_sse:
            best_sse, best_Tb = sse, Tb
    return int(best_Tb if best_Tb is not None else Tn//2)

def forecast_sarima_estimated_break(y_train, order=(1,0,0), seasonal_order=(1,0,0,12), trim=0.15):
    """
    1) Estimate Tb_hat from y_train
    2) Fit SARIMA using break dummy based on Tb_hat
    3) Forecast 1-step ahead
    """
    y = np.asarray(y_train, dtype=float)
    Tb_hat = estimate_break_grid_sse_mean_only(y, trim=trim)

    t_idx = np.arange(len(y))
    d = (t_idx > Tb_hat).astype(float).reshape(-1, 1)

    m = SARIMAX(
        y,
        order=order,
        seasonal_order=seasonal_order,
        exog=d,
        trend="c",
        enforce_stationarity=False,
        enforce_invertibility=False
    ).fit(disp=False)

    d_next = np.array([[1.0 if len(y) > Tb_hat else 0.0]])
    return float(m.forecast(1, exog=d_next)[0])

def forecast_ses(y_train):
    m = SimpleExpSmoothing(y_train, initialization_method="estimated").fit(optimized=True)
    return float(m.forecast(1)[0])


# =========================================================
# 3) Monte Carlo evaluation
# =========================================================
def run_mc_single_break_sarima(
    n_sim=200,
    T=300,
    Tb=150,
    window=60,
    seed=123,
    mu0=0.0,
    mu1=2.0,
    phi=0.6,
    sigma=1.0,
    s=12,
    A=1.0,
    gap_after_break=20,
    order=(1,0,0),
    seasonal_order=(1,0,0,12),
    trim=0.15
):
    rng = np.random.default_rng(seed)
    t0 = Tb + gap_after_break
    if t0 >= T:
        raise ValueError("gap_after_break too large for T.")

    methods = [
        ("SARIMA Global", lambda ytr: forecast_sarima_global(ytr, order=order, seasonal_order=seasonal_order)),
        ("SARIMA Rolling", lambda ytr: forecast_sarima_rolling(ytr, window=window, order=order, seasonal_order=seasonal_order)),
        ("SARIMA + Break Dummy (oracle Tb)", lambda ytr: forecast_sarima_break_dummy_oracle(ytr, Tb=Tb, order=order, seasonal_order=seasonal_order)),
        ("SARIMA + Estimated Break (grid)", lambda ytr: forecast_sarima_estimated_break(ytr, order=order, seasonal_order=seasonal_order, trim=trim)),
        ("Simple Exp. Smoothing (SES)", lambda ytr: forecast_ses(ytr)),
    ]

    errors = {name: [] for name, _ in methods}
    fails  = {name: 0 for name, _ in methods}

    for _ in range(n_sim):
        y = simulate_single_break_with_seasonality(
            T=T, Tb=Tb, mu0=mu0, mu1=mu1, phi=phi, sigma=sigma, s=s, A=A, rng=rng
        )
        y_train = y[:t0]
        y_true  = float(y[t0])

        for name, func in methods:
            try:
                f = func(y_train)
                errors[name].append(y_true - f)
            except Exception:
                fails[name] += 1

    rows = []
    for name in errors:
        e = np.asarray(errors[name], dtype=float)
        if len(e) == 0:
            rows.append({"Method": name, "RMSE": np.nan, "MAE": np.nan, "Bias": np.nan, "N": 0, "Fails": fails[name]})
        else:
            rows.append({
                "Method": name,
                "RMSE": float(np.sqrt(np.mean(e**2))),
                "MAE":  float(np.mean(np.abs(e))),
                "Bias": float(np.mean(e)),
                "N": int(len(e)),
                "Fails": fails[name]
            })

    return pd.DataFrame(rows).sort_values("RMSE", na_position="last").reset_index(drop=True)


# =========================================================
# 4) RUN + RESULTS
# =========================================================
results = run_mc_single_break_sarima(
    n_sim=200,
    T=300,
    Tb=150,
    window=60,
    seed=123,
    mu0=0.0,
    mu1=2.0,
    phi=0.6,
    sigma=1.0,
    s=12,
    A=1.0,
    gap_after_break=20,
    order=(1,0,0),
    seasonal_order=(1,0,0,12),
    trim=0.15
)

print("\nSingle-break SARIMA-based results (lower RMSE = better):")
print(results.to_string(index=False))

best = results.dropna(subset=["RMSE"]).head(1)
if len(best) > 0:
    print(f"\nConclusion: Best method (lowest RMSE) = {best.iloc[0]['Method']}")
else:
    print("\nConclusion: All methods failed.")


# =========================================================
# 5) VISUAL GRAPHS
# =========================================================
plot_df = results.copy().sort_values("RMSE", na_position="last")

plt.figure(figsize=(12,4))
plt.bar(plot_df["Method"], plot_df["RMSE"])
plt.title("Single-break: RMSE by method (SARIMA setting)")
plt.ylabel("RMSE")
plt.grid(True, axis="y", alpha=0.3)
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

plt.figure(figsize=(12,4))
plt.bar(plot_df["Method"], plot_df["MAE"])
plt.title("Single-break: MAE by method (SARIMA setting)")
plt.ylabel("MAE")
plt.grid(True, axis="y", alpha=0.3)
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

plt.figure(figsize=(12,4))
plt.bar(plot_df["Method"], plot_df["Bias"])
plt.axhline(0, linestyle="--", linewidth=2)
plt.title("Single-break: Bias by method (SARIMA setting)")
plt.ylabel("Bias")
plt.grid(True, axis="y", alpha=0.3)
plt.xticks(rotation=20, ha="right")
plt.tight_layout()
plt.show()

# Example series with break
T=300; Tb=150
y_demo = simulate_single_break_with_seasonality(
    T=T, Tb=Tb, mu0=0.0, mu1=2.0, phi=0.6, sigma=1.0, s=12, A=1.0, rng=np.random.default_rng(999)
)

plt.figure(figsize=(12,4))
plt.plot(y_demo, label="Simulated series (with seasonality)")
plt.axvline(Tb, linestyle="--", linewidth=2, label=f"Break Tb={Tb}")
plt.title("Example series: single mean break + seasonality (SARIMA relevant)")
plt.xlabel("Time")
plt.ylabel("y")
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()